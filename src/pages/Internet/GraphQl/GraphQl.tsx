import graphqlvsrest from '../../../images/InternetImages/GraphQl/graphqlvsrest.jpeg'
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";
;


export default function GraphQl() {
  
  return (
    <section className="topic container">
      <h2>Что такое GraphQL?</h2>
      <p>
        <strong>GraphQL</strong> — это язык запросов к данным и среда их выполнения, разработанная Facebook. Он позволяет клиенту запрашивать ровно те данные, которые ему нужны, и не больше.
      </p>
      <p>
        Иначе говоря, GraphQL даёт клиенту контроль: что запросить, как глубоко, с какими связями — и получить всё это за один запрос.
      </p>

      <h3>Пояснение простыми словами</h3>
      <p>
        REST работает по принципу «один запрос — один ресурс». GraphQL — это как меню, где ты сам выбираешь, какие именно поля, под-поля и вложенные данные тебе нужны, и получаешь их одной порцией.
      </p>

      <p>
        <em>Пример из жизни:</em> REST — это как ресторан с фиксированным обедом: первое, второе, компот. Даже если ты хочешь только салат, тебе принесут всё. GraphQL — это как шведский стол: ты сам кладёшь на тарелку только то, что нужно.
      </p>

      <h3>Как работает GraphQL?</h3>
      <ol>
        <li>Клиент отправляет один <strong>запрос</strong> с описанием нужных данных (в виде специального синтаксиса).
        </li>
        <li>Сервер читает этот запрос и возвращает <strong>ровно те поля</strong>, которые были запрошены.
        </li>
        <li>Если клиенту в следующий раз нужно что-то другое — он просто меняет запрос, а не ждёт новый endpoint от сервера.</li>
      </ol>

      <h3>Как выглядит запрос?</h3>
      <p>Простой пример запроса на GraphQL:</p>
      <pre>
        <code>{`{
  user(id: "1") {
    name
    email
    posts {
      title
      likes
    }
  }
}`}</code>
      </pre>
      <p>
        Такой запрос сразу вернёт пользователя, его имя, email и список постов с названиями и лайками — одной порцией.
      </p>

      <h3>Преимущества GraphQL</h3>
      <ul>
        <li><strong>Гибкость:</strong> клиент сам решает, какие поля нужны.</li>
        <li>
          <strong>Меньше данных:</strong> только нужная информация, никаких лишних структур.
        </li>
        <li>
          <strong>Один endpoint:</strong> всё работает через одну точку входа, например <code>/graphql</code>.
        </li>
        <li>
          <strong>Вложенные связи:</strong> можно запрашивать сразу связанные объекты и их поля.
        </li>
        <li>
          <strong>Документация встроена:</strong> сама схема уже содержит всю информацию о доступных типах и запросах.
        </li>
      </ul>

      <h3>Недостатки и ограничения</h3>
      <ul>
        <li>Больше логики и ответственности на стороне сервера.</li>
        <li>Сложнее кэшировать (по сравнению с REST и HTTP-заголовками).</li>
        <li>Не идеально подходит для простых проектов с фиксированными структурами данных.</li>
      </ul>

      <h3>GraphQL против REST</h3>
      <p>
        <strong>Точки входа (endpoints):</strong><br />
        REST использует много точек входа — по одной для каждого ресурса.<br />
        GraphQL имеет одну единственную точку входа.
      </p>
      <p>
        <strong>Получение вложенных данных:</strong><br />
        В REST для получения связанных данных обычно нужно делать несколько запросов.<br />
        В GraphQL можно получить все вложенные данные одним запросом с нужной структурой.
      </p>
      <p>
        <strong>Объём данных:</strong><br />
        В REST объём данных фиксирован, часто возвращаются лишние поля, которые могут не понадобиться.<br />
        В GraphQL клиент запрашивает только те поля, которые ему нужны, что делает ответ гибким.
      </p>
      <p>
        <strong>Поддержка кэширования:</strong><br />
        В REST кэширование проще и поддерживается на уровне HTTP-протокола.<br />
        В GraphQL кэширование сложнее и требует дополнительной ручной настройки.
      </p>
      <p>
        <strong>Простота начальной реализации:</strong><br />
        REST обычно проще и быстрее реализовать на начальном этапе.<br />
        GraphQL требует чуть больше усилий для настройки и понимания.
      </p>
      <img
        src={graphqlvsrest}
        alt=""
        width=""
        height=""
        loading="lazy"
      />
      <h3>Когда GraphQL — это отличное решение</h3>
      <ul>
        <li>У клиента сложные и гибкие требования к структуре данных.</li>
        <li>Много разных источников данных на сервере (например, БД + сторонние API).</li>
        <li>Нужно получать много связанных объектов за один запрос.</li>
        <li>Проект — мобильный или работает в условиях слабой связи (экономия трафика).</li>
      </ul>

      <h3>Когда GraphQL — скорее перебор</h3>
      <ul>
        <li>Простой сайт или приложение с фиксированными страницами.</li>
        <li>Небольшая команда без опыта работы с GraphQL.</li>
        <li>Важно простое кэширование и максимальная предсказуемость URL-структуры.</li>
      </ul>
      <h2>Итого</h2>
      <ul>
        <li><strong>GraphQL</strong> даёт клиенту гибкий и точный контроль над запрашиваемыми данными.</li>
        <li>Он позволяет получить вложенные и связанные данные одним запросом через единый endpoint.</li>
        <li>Это удобно для сложных приложений с разнообразными источниками данных и гибкими требованиями.</li>
        <li>Однако GraphQL сложнее в реализации и кэшировании по сравнению с REST.</li>
        <li><strong>REST</strong> проще и лучше подходит для классических API с предсказуемой структурой данных и простыми запросами.</li>
        <li>Выбор между GraphQL и REST зависит от конкретных потребностей проекта и команды.</li>
      </ul>
      <NavButtons prev={'/internet/WebSocket'} next={'/internet'} />
    </section>
  );
}
