import VsCode from "../../../components/VsCode/VsCode.tsx";
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";

export default function Save() {

  return (
    <section className="container topic">
      <h2>Как сохраняются изменения в Git</h2>

      <h3>Git не следит за всем сам — вы говорите ему, что важно</h3>
      <p>
        Когда вы что-то меняете в проекте — редактируете файл, добавляете новый или удаляете — Git не начинает паниковать и не пытается сразу всё записать. Он ждёт. Ждёт, когда вы скажете: "Вот эти изменения — важны, сохрани их". Для этого служит команда:
      </p>

      <VsCode>{`git add имя_файла`}</VsCode>

      <p>
        Это как положить документ в папку "готово к подписи". Пока файл не добавлен — Git про него *помнит*, но не фиксирует.
      </p>

      <h3>Хочу сразу всё</h3>
      <p>
        Не хотите добавлять файлы по одному? Есть короткий способ:
      </p>

      <VsCode>{`git add .`}</VsCode>

      <p>
        Точка — значит "всё в этой папке и ниже". Удобно, когда вы поработали сразу над несколькими файлами.
      </p>

      <h3>add — это ещё не сохранение</h3>
      <p>
        После <code>git add</code> Git знает, какие файлы вы хотите сохранить. Но он ещё ничего не записал в историю. Чтобы зафиксировать изменения, используется:
      </p>

      <VsCode>{`git commit -m "Сообщение, что сделано"`}</VsCode>

      <p>
        Вот это уже и есть «сохранение» в понимании Git. Он делает снимок проекта, сохраняет всё, что вы добавили, и пишет к этому коммент. Это сообщение потом пригодится вам, команде и будущему «вам из будущего», который будет разбираться, что когда и зачем менялось.
      </p>

      <h3>Работает как контрольная точка</h3>
      <p>
        Каждый коммит — это точка, к которой можно вернуться. Представьте, что вы играете в игру, сделали сейв перед сложным боссом — вот это и есть коммит. Сломали проект? Возвращаемся. Коммит — наш бекап.
      </p>
      <h3>Git и пустые папки</h3>

      <p>Иногда кажется логичным: создал папку — значит, она есть в проекте. Но не для Git.</p>

      <p>
        <strong>Git по умолчанию не отслеживает пустые папки.</strong> То есть если внутри директории нет файлов — Git просто "не видит" её и не добавит в коммит.
      </p>

      <p>Почему так? Git отслеживает содержимое проекта, а не структуру. Он считает, что папки нужны только как "контейнеры" для файлов, и если контейнер пуст — его как бы и нет.</p>

      <h3>Как сохранить пустую папку в репозитории?</h3>

      <p>Добавьте в неё служебный файл. Принятое решение — создать файл <code>.gitkeep</code>. Это обычный пустой файл, который говорит Git'у: "папка нужна, сохрани её".
      </p>

      <p>Пример:</p>

      <VsCode>{`mkdir uploads
touch uploads/.gitkeep
git add uploads/.gitkeep
git commit -m "Добавил пустую папку uploads с .gitkeep"
      `}</VsCode>

      <p>Некоторые используют <code>.keep</code> или <code>README.md</code> с пояснением — это не принципиально. Главное, чтобы внутри был хоть один файл.
      </p>


      <h3>Git Reset — как откатиться назад</h3>

      <p>Иногда хочется вернуть всё, как было. И тут в ход идёт <code>git reset</code>.
      </p>

      <h3>Что делает <code>git reset</code></h3>

      <p>Он откатывает изменения — но <strong>в зависимости от флага</strong>, делает это по-разному. Важно понимать, что речь идёт о трёх “зонах” Git:
      </p>

      <ul>
        <li><strong>Commit history</strong> — история коммитов</li>
        <li><strong>Staging area</strong> — подготовленные к коммиту файлы</li>
        <li><strong>Working directory</strong> — текущие файлы в проекте</li>
      </ul>

      <h3>Варианты команды</h3>

      <p><strong>1. Мягкий откат — оставляет всё в stage:</strong></p>
      <VsCode>{`git reset --soft HEAD~1`}</VsCode>
      <p>Откатит последний коммит, но изменения останутся в индексе (stage). Можно перезаписать сообщение коммита.</p>

      <p>
        <strong>2. Средний откат — вернёт изменения в рабочую директорию:</strong>
      </p>
      <VsCode>{`git reset --mixed HEAD~1`}</VsCode>
      <p>Снимает файлы со stage, но оставляет в рабочей директории. По умолчанию используется именно <code>--mixed</code>.
      </p>

      <p><strong>3. Жёсткий откат — полное удаление изменений:</strong></p>
      <VsCode>{`git reset --hard HEAD~1`}</VsCode>
      <p>Удалит коммит, уберёт из stage и из директории. Осторожно: так можно потерять код.</p>

      <h3>Что значит <code>HEAD~1</code>?</h3>
      <p>
        <code>HEAD</code> — это текущий коммит. <code>~1</code> — значит "на один назад". Можно писать <code>~2</code>, <code>~3</code> и т.д.
      </p>

      <h3>А если хочется просто убрать файлы из stage?</h3>
      <VsCode>{`git reset`}</VsCode>
      <p>Без параметров — просто снимает все staged-файлы. Изменения останутся в директории.</p>


      <h2>Итого</h2>
      <ul>
        <li>
          <code>git add</code> — добавляет файл в список тех, что нужно зафиксировать.
        </li>
        <li><code>git add .</code> — добавляет все изменения в текущей папке.
        </li>
        <li>
          <code>git commit</code> — создаёт контрольную точку проекта с описанием.
        </li>
        <li>Git не сохраняет сам — вы сами решаете, что и когда записывать в историю.</li>
        <li>Каждый коммит — это как сейв в игре: можно откатиться и начать заново.</li>
      </ul>
      <NavButtons prev={'/git/Config'} next={'/git/GoodCommit'} />
    </section>
  )
}
