import VsCode from "../../../components/VsCode/VsCode.tsx";
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";
import Test from "../../../components/Test/Test.tsx";


type ContextProps = {}

export default function Context(props: ContextProps) {
  const {} = props

  return (
    <section className={'topic container'}>
      <h2>Область видимости и контекст</h2>
      <p>
        <strong>Область видимости</strong> — это часть программы, где определённые переменные и функции доступны для использования.
      </p>
      <p>Область видимости создаётся с помощью блоков кода — например, фигурных скобок <code>{'{}'}</code>, функций, модулей или классов. Переменные, объявленные внутри области, недоступны снаружи. Исключение составляет <code>var</code>, которая имеет функциональную или глобальную область видимости, а не блочную.
      </p>
      <VsCode>{`{
  let a = 10;
  console.log(a); // 10
}
console.log(a); // ReferenceError: a is not defined`}</VsCode>

      <p>JavaScript поддерживает лексическую (статическую) область видимости — доступность переменных определяется по расположению кода при написании, а не во время выполнения.</p>

      <h4>Блочная и функциональная области видимости</h4>
      <p>
        <strong>Блочная область видимости</strong> создаётся внутри ближайших фигурных скобок <code>{'{}'}</code>, например, в условиях, циклах, или просто блоках кода. Переменные, объявленные через <code>let</code> и <code>const</code>, видны только внутри такого блока:
      </p>
      <VsCode>{`{
  let x = 5;
  const y = 10;
  console.log(x, y); // 5 10
}
console.log(x); // ReferenceError: x is not defined
console.log(y); // ReferenceError: y is not defined`}</VsCode>

      <p>
        <strong>Функциональная область видимости</strong> охватывает весь код внутри функции. Переменные, объявленные через <code>var</code>, видны во всей функции, даже если объявлены внутри блоков:
      </p>
      <VsCode>{`function example() {
  if (true) {
    var z = 20;
  }
  console.log(z); // 20 — переменная видна во всей функции
}
example();
console.log(z); // ReferenceError: z is not defined (вне функции)`}</VsCode>

      <p>Таким образом:</p>
      <ul>
        <li><code>var</code> — имеет <em>функциональную</em> область видимости;
        </li>
        <li>
          <code>let</code> и <code>const</code> — имеют <em>блочную</em> область видимости.
        </li>
      </ul>
      <p>Это одна из причин, почему <code>let</code> и <code>const</code> рекомендуют использовать вместо <code>var</code>, чтобы избежать неожиданных ошибок из-за «всплытия» переменных.
      </p>

      <h3>Контекст выполнения (execution context)</h3>
      <p>
        <strong>Контекст выполнения</strong> — это внутренняя среда, в которой выполняется код. Контекст содержит всю информацию, необходимую для правильного выполнения текущего кода: какие переменные и функции доступны, какое значение у <code>this</code>, а также параметры и локальные переменные текущей функции.
      </p>

      <p>Каждый раз, когда вызывается функция, создаётся новый контекст выполнения. Даже при выполнении глобального кода создаётся глобальный контекст. Контексты располагаются в стеке — текущий контекст находится сверху, и когда функция заканчивает выполнение, её контекст снимается со стека.</p>

      <p>Контекст выполнения включает в себя несколько ключевых компонентов:</p>
      <ul>
        <li>
          <strong>Лексическая область видимости</strong> — ссылки на переменные и функции, доступные в текущем месте кода.
        </li>
        <li>
          <strong>Значение <code>this</code></strong> — указывает на объект, к которому относится текущий вызов функции.
        </li>
        <li>
          <strong>Параметры и локальные переменные</strong> — данные, объявленные внутри функции или переданные в неё.
        </li>
      </ul>

      <p>Проще говоря, контекст — это как «рабочее пространство» для функции, в котором она хранит все необходимые данные и окружение для своего выполнения.</p>

      <h4>Пример контекста выполнения</h4>
      <VsCode>{`function greet(name) {
  console.log('Hello, ' + name);
  console.log('this:', this);
}

const user = { name: 'Alice', greet: greet };

// Вызов функции в глобальном контексте
greet('World'); 
// Вызов метода объекта — this ссылается на объект user
user.greet();`}</VsCode>

      <p>Что происходит при вызове <code>greet('World')</code>:</p>
      <ul>
        <li>Создаётся новый контекст выполнения функции <code>greet</code>.</li>
        <li>В лексической области видимости есть параметр <code>name</code> со значением <code>'World'</code>.
        </li>
        <li>
          <code>this</code> указывает на глобальный объект (<code>window</code> в браузере или <code>global</code> в Node.js).
        </li>
        <li>Выполняется тело функции, выводятся сообщения в консоль.</li>
        <li>После выполнения контекст удаляется.</li>
      </ul>

      <p>При вызове <code>user.greet()</code> создаётся новый контекст, но <code>this</code> теперь ссылается на объект <code>user</code>, потому что функция вызвана как метод объекта.
      </p>

      <p>Таким образом, контекст выполнения — это механизм, который позволяет функции «знать», где и как она была вызвана, какие переменные доступны и что означает <code>this</code> внутри неё.
      </p>

      <h2>Итого</h2>
      <ul>
        <li>
          <strong>Область видимости</strong> определяет, <em>где в коде</em> доступна переменная. Она зависит от структуры кода и создаётся с помощью блоков <code>{'{}'}</code>, функций, классов и модулей.
        </li>
        <li>
          <code>let</code> и <code>const</code> — имеют <strong>блочную</strong> область видимости (только внутри <code>{'{}'}</code>).
        </li>
        <li>
          <code>var</code> — имеет <strong>функциональную</strong> область видимости (во всей функции, даже за пределами блока).
        </li>
        <li>
          JavaScript использует <strong>лексическую область видимости</strong> — доступность переменных определяется по месту их объявления в коде.
        </li>
        <li>
          <strong>Контекст выполнения</strong> создаётся при каждом вызове функции и включает:
          <ul>
            <li>Лексическую область видимости (какие переменные видны)</li>
            <li>Значение <code>this</code> (на что указывает текущий вызов)</li>
            <li>Параметры и локальные переменные функции</li>
          </ul>
        </li>
        <li>
          Значение <code>this</code> зависит от <strong>места вызова функции</strong>, а не от того, где она была объявлена.
        </li>
      </ul>
      <NavButtons
        prev={'/js/Objects'}
        next={'/js/This'}
      />
      <Test
        allTasks={[
          {
            question: "Какую область видимости имеет переменная, объявленная с помощью var внутри функции?",
            variants: [
              "Глобальную",
              "Блочную",
              "Функциональную",
              "Модульную"
            ],
            explanations: [
              "var, объявленная вне функции, будет глобальной, но внутри функции — ограничена функцией.",
              "Блочная область для var не применяется — это для let и const.",
              "var имеет функциональную область видимости — видна во всей функции, где объявлена.",
              "Модули имеют свою область, но var не связана с модульной областью."
            ],
            correct: 2,
            isCode: false
          },
          {
            question: "Что выведет этот код и почему?",
            isCode: true,
            code: `function test() {
  console.log(a);
  var a = 5;
}
test();`,
            variants: [
              "undefined",
              "5",
              "ReferenceError",
              "null"
            ],
            explanations: [
              "var поднимается (hoisting), поэтому переменная существует, но неинициализирована, даёт undefined.",
              "Переменная объявляется после console.log, поэтому 5 не будет выведено.",
              "Ошибка не происходит, т.к. var объявлена в функции.",
              "null не используется здесь."
            ],
            correct: 0
          },
          {
            question: "Что будет выведено и почему?",
            isCode: true,
            code: `const obj = {
  name: "Alice",
  getName: () => this.name
};
console.log(obj.getName());`,
            variants: [
              '"Alice"',
              "undefined",
              "ReferenceError",
              "null"
            ],
            explanations: [
              "Стрелочные функции не имеют своего this, берут из внешнего контекста — здесь глобальный объект.",
              "this указывает не на obj, а на глобальный объект, у которого нет свойства name.",
              "Ошибка не возникает, просто значение undefined.",
              "null не возвращается."
            ],
            correct: 1
          },
          {
            question: "Что будет результатом выполнения?",
            isCode: true,
            code: `{
  let x = 10;
  {
    var y = 20;
  }
  console.log(x);
  console.log(y);
}`,
            variants: [
              "10 и 20",
              "ReferenceError и 20",
              "10 и ReferenceError",
              "ReferenceError и ReferenceError"
            ],
            explanations: [
              "let ограничена блоком, но x объявлен во внешнем блоке — доступен, var игнорирует блок и доступен во всей функции/глобале.",
              "let x определён, ошибки не будет, var y будет поднята в глобальный/функциональный контекст.",
              "Ошибка при доступе к y не возникнет, потому что var не блочная.",
              "Ошибок нет для x и y, ReferenceError не будет."
            ],
            correct: 0
          }
        ]}
      />
      <NavButtons
        prev={'/js/Objects'}
        next={'/js/This'}
      />
    </section>
  )
}
