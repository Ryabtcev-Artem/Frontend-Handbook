import VsCode from "../../../components/VsCode/VsCode.tsx";
import Test from "../../../components/Test/Test.tsx";
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";

type ClosuresProps = {}
export default function Closures(props: ClosuresProps) {
  const {} = props

  return (
    <section className="topic container">
      <h2>Замыкания (Closures) в JavaScript</h2>

      <p>
        <strong>Замыкание</strong> — это механизм языка, благодаря которому функция «запоминает» окружение, в котором была создана, и может обращаться к переменным этой среды даже после того, как внешняя функция уже завершила своё выполнение.
      </p>
      <p>
        Проще говоря, замыкание — это функция вместе с «связкой» (лексическим окружением) всех переменных, к которым она имеет доступ.
      </p>

      <h3>Как это работает?</h3>
      <p>
        Когда в JavaScript вызывается функция, у неё появляется локальная область видимости — набор переменных, доступных внутри неё. Если внутри этой функции создаётся и возвращается другая функция, то у возвращённой функции сохраняется доступ к переменным родительской функции — даже если сама родительская функция уже отработала.
      </p>
      <p>
        Это и есть замыкание — внутренние функции «замыкают» значения переменных из внешнего окружения.
      </p>

      <h3>Пример:</h3>
      <VsCode>{`function makeCounter() {
  let count = 0;

  return function() {
    count++;
    return count;
  };
}

const counter = makeCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3`}
      </VsCode>

      <h3>Интересный факт:</h3>
      <p>
        Замыкания — по сути, это просто вызов функции, которая обращается к переменной, находящейся вне её локальной области, но в доступном лексическом окружении.
      </p>
      <p>Например, если функция просто обращается к глобальной переменной, это тоже замыкание, ведь она «замыкает» эту переменную из глобального контекста:</p>
      <VsCode>{`let globalVar = 10;

function printGlobal() {
  console.log(globalVar); // доступ к внешней (глобальной) переменной
}

printGlobal(); // 10`}
      </VsCode>

      <p>
        То есть любое обращение функции к внешним переменным — уже замыкание, но чаще замыкания ассоциируются именно с функциями, которые «помнят» своё окружение после завершения внешнего вызова.
      </p>

      <h3>Где применяются замыкания?</h3>
      <ul>
        <li>Создание приватных данных и инкапсуляция (переменные вне доступа снаружи, но доступные для внутренних функций).</li>
        <li>Функции с частично заданными аргументами (каррирование).</li>
        <li>Создание функций с сохранённым состоянием.</li>
        <li>Обработчики событий, колбеки и асинхронный код, где важно сохранить данные в момент создания функции.</li>
      </ul>

      <h3>Краткий итог:</h3>
      <ul>
        <li>Замыкание — это функция вместе с лексическим окружением, которое она «запомнила».</li>
        <li>Замыкания позволяют функции «помнить» значения переменных вне своего тела.</li>
        <li>Обращение к глобальной переменной — тоже замыкание, но замыкания обычно ассоциируют с сохранением локальных данных.</li>
        <li>Это мощный инструмент, который лежит в основе многих приёмов программирования в JavaScript.</li>
      </ul>
      <NavButtons prev={'/js/FunctionTypes'} next={'/js/Curry'} />

      <Test
        allTasks={[
          {
            question: 'Что такое замыкание в JavaScript?',
            variants: [
              'Функция вместе с сохранённым лексическим окружением, в котором она была создана',
              'Приватное свойство объекта',
              'Объект, содержащий все глобальные переменные',
              'Механизм асинхронного выполнения кода'
            ],
            explanations: [
              'Замыкание — это функция с доступом к переменным из своей внешней лексической области, даже после завершения этой внешней функции.',
              'Приватные свойства — это не замыкания, а другая концепция инкапсуляции.',
              'Глобальные переменные не образуют замыкания.',
              'Асинхронность не связана напрямую с замыканиями.'
            ],
            correct: 0,
            isCode: false
          },

          {
            question: 'Что вернёт следующий код?',
            code: `function makeCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}
const counter = makeCounter();
console.log(counter());
console.log(counter());`,
            variants: [
              '1\n2',
              '0\n1',
              'undefined\nundefined',
              '2\n3'
            ],
            explanations: [
              'Каждый вызов увеличивает count на 1, начиная с 0, поэтому вывод будет 1 и 2.',
              'count начинается с 0, но возвращается после увеличения, так что первый вывод не 0.',
              'count определён и возвращается, поэтому не undefined.',
              'Первый вызов возвращает 1, второй 2, а не 2 и 3.'
            ],
            correct: 0,
            isCode: true
          },

          {
            question: 'Какое из утверждений про замыкания неверно?',
            variants: [
              'Замыкания могут использоваться для создания приватных переменных.',
              'Функция всегда создаёт замыкание, когда вызывается.',
              'Замыкание позволяет функции «помнить» переменные вне её тела.',
              'Обращение к глобальной переменной функцией — это тоже замыкание.'
            ],
            explanations: [
              'Это верное свойство замыканий — инкапсуляция данных.',
              'Замыкание создаётся в момент создания функции, а не при вызове.',
              'Это ключевая особенность замыканий — доступ к лексическому окружению.',
              'Доступ к глобальной переменной — частный случай замыкания.'
            ],
            correct: 1,
            isCode: false
          },

          {
            question: 'Что произойдёт в этом коде?',
            code: `function outer() {
  let x = 10;
  return function inner() {
    return x;
  }
}
const fn = outer();
console.log(fn());`,
            variants: [
              'Выведет 10',
              'Выдаст ошибку, что x не определён',
              'Выведет undefined',
              'Выведет функцию inner'
            ],
            explanations: [
              'Внутренняя функция замыкает значение x из внешней функции и возвращает 10.',
              'Переменная x доступна внутренней функции через замыкание.',
              'x инициализирована и возвращается, не undefined.',
              'fn — это функция, вызов fn() вернёт значение x, а не функцию.'
            ],
            correct: 0,
            isCode: true
          }
        ]}
      />
      <NavButtons prev={'/js/FunctionTypes'} next={'/js/Curry'} />
    </section>
  )
}