import VsCode from "../../../components/VsCode/VsCode.tsx";
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";
export default function Intro() {
  return (
    <section className={'topic container'}>
      <h2>Что такое React</h2>
      <p>React — это JavaScript-библиотека для создания пользовательских интерфейсов, разработанная Facebook. Она позволяет строить интерфейсы из независимых компонентов, которые управляют своим состоянием и могут переиспользоваться в разных частях приложения.</p>

      <p>В отличие от фреймворков, React решает одну конкретную задачу — эффективное обновление DOM при изменении данных. Он не диктует, как организовать маршрутизацию или работу с сервером, оставляя эти решения разработчику.</p>

      <h3>Почему ванильный JavaScript недостаточен</h3>
      <p>При разработке сложных интерфейсов на чистом JavaScript возникают системные проблемы. Когда данные изменяются, вам нужно найти все элементы DOM, которые должны обновиться, и изменить их вручную. Это приводит к запутанному коду, где логика обновления интерфейса размазана по всему приложению.</p>

      <VsCode>{`// Ванильный JS - много ручной работы
const counter = document.getElementById('counter');
const button = document.getElementById('increment');
let count = 0;

button.addEventListener('click', () => {
  count++;
  counter.textContent = count;
  // И так для каждого элемента...
});`}</VsCode>

      <p>В большом приложении таких связей между данными и интерфейсом сотни. Отследить их все становится невозможно, а любое изменение может сломать что-то в другом месте.</p>

      <h3>Декларативный подход</h3>
      <p>React предлагает декларативный подход — вы описываете, как должен выглядеть интерфейс для каждого состояния данных, а библиотека сама разбирается, что нужно обновить в DOM.</p>

      <VsCode>{`// React - описываем желаемый результат
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}`}</VsCode>

      <p>Вместо императивных команд "найди элемент, измени его содержимое" вы говорите "при таком состоянии интерфейс должен выглядеть так". React сам выяснит, что именно нужно изменить.</p>

      <h3>Компонентная архитектура</h3>
      <p>React строится на концепции компонентов — независимых фрагментов интерфейса со своей логикой и состоянием. Компонент получает данные через пропсы и возвращает разметку, описывающую, как он должен отображаться.</p>

      <VsCode>{`function UserCard({ name, email, avatar }) {
  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
}

// Можно использовать многократно
<UserCard name="Анна" email="anna@example.com" avatar="anna.jpg" />
<UserCard name="Петр" email="petr@example.com" avatar="petr.jpg" />`}</VsCode>

      <p>Такой подход решает проблему дублирования кода и делает интерфейс предсказуемым — один компонент всегда ведет себя одинаково при одинаковых входных данных.</p>

      <h3>Virtual DOM и производительность</h3>
      <p>React использует Virtual DOM — JavaScript-представление реального DOM-дерева. При изменении состояния React создает новое виртуальное дерево, сравнивает его с предыдущим и вносит в настоящий DOM только минимально необходимые изменения.</p>

      <p>Это решает проблему производительности — вместо перерисовки всего интерфейса обновляются только те элементы, которые действительно изменились. Разработчик при этом может писать код так, будто весь интерфейс перерисовывается целиком.</p>

      <h3>Однонаправленный поток данных</h3>
      <p>В React данные передаются строго сверху вниз — от родительских компонентов к дочерним через пропсы. Дочерние компоненты не могут напрямую изменить данные родителя, но могут вызвать переданную функцию для уведомления о событии.</p>

      <VsCode>{`function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text }]);
  };
  
  return (
    <div>
      <TodoForm onSubmit={addTodo} />
      <TodoList todos={todos} />
    </div>
  );
}`}</VsCode>

      <p>Такая архитектура делает поведение приложения предсказуемым — всегда понятно, откуда приходят данные и как они могут измениться.</p>

      <h3>Экосистема и инструменты</h3>
      <p>React имеет развитую экосистему библиотек для решения типовых задач: React Router для маршрутизации, Redux для управления состоянием, Material-UI для готовых компонентов. Это позволяет не изобретать велосипед для каждой задачи.</p>

      <p>Инструменты разработки включают React DevTools для отладки компонентов, Create React App для быстрого старта проекта, и горячую перезагрузку для мгновенного отображения изменений в коде.</p>

      <h3>JSX — расширение JavaScript</h3>
      <p>React использует JSX — синтаксическое расширение JavaScript, которое позволяет писать HTML-подобную разметку прямо в коде. JSX компилируется в обычные вызовы функций React.</p>

      <VsCode>{`// JSX
const element = <h1>Привет, мир!</h1>;

// Компилируется в:
const element = React.createElement('h1', null, 'Привет, мир!');`}</VsCode>

      <p>JSX делает код более читаемым и позволяет использовать всю мощь JavaScript для создания динамической разметки с условиями, циклами и выражениями.</p>

      <h2>Итого</h2>
      <ul>
        <li>React — библиотека для создания пользовательских интерфейсов, которая решает проблемы масштабирования и поддержки сложных приложений</li>
        <li>Декларативный подход позволяет описывать желаемый результат вместо пошагового управления DOM</li>
        <li>Компонентная архитектура делает код переиспользуемым и предсказуемым</li>
        <li>Virtual DOM обеспечивает высокую производительность при простоте написания кода</li>
        <li>Однонаправленный поток данных упрощает понимание и отладку приложения</li>
        <li>Развитая экосистема предоставляет готовые решения для типовых задач</li>
        <li>JSX объединяет удобство HTML-разметки с мощью JavaScript</li>
      </ul>
      <NavButtons prev={'/react'} next={'/react/Setup'} />
    </section>
  )
}