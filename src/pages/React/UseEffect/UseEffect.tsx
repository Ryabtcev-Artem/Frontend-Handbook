import VsCode from "../../../components/VsCode/VsCode.tsx";
import NavButtons from "../../../components/NavButtons/NavButtons.tsx";

export default function UseEffect() {
  return (
    <section className={'topic container'}>
      <h2>useEffect: что это и зачем нужен</h2>

      <h3>Что такое useEffect</h3>
      useEffect — это хук в React, который позволяет выполнять побочные эффекты в функциональных компонентах. Побочные эффекты — это любые операции, которые не относятся напрямую к отрисовке интерфейса, например:

      - Запросы к серверу (fetch, axios)
      - Работа с таймерами (setTimeout, setInterval)
      - Подписки на события (например, на window или document)
      - Изменение DOM вне React
      - Очистка ресурсов при размонтировании компонента

      useEffect заменяет методы жизненного цикла из классовых компонентов — componentDidMount, componentDidUpdate и componentWillUnmount.

      <h3>Как использовать useEffect</h3>
      useEffect принимает два аргумента:

      1. Функцию, которая содержит код эффекта. В эту функцию можно вернуть другую функцию — функцию очистки, которая выполнится перед повторным запуском эффекта или при размонтировании компонента.
      2. Массив зависимостей — список значений, от изменения которых зависит вызов эффекта.

      Пример базового использования:

      <VsCode>{`useEffect(() => {
  console.log('Компонент смонтировался или обновился');

  return () => {
    console.log('Очистка перед следующим вызовом эффекта или размонтированием');
  }
}, []);`}</VsCode>

      <h3>Зачем нужен массив зависимостей</h3>
      Массив зависимостей определяет, когда именно будет запускаться эффект. React сравнивает текущие значения зависимостей с предыдущими и вызывает эффект только если что-то изменилось.

      Подробнее про массив зависимостей вы найдёте в следующем разделе.

      <h3>Примеры использования</h3>

      <ul>
        <li><b>Запрос данных при загрузке страницы </b>
           Чтобы сделать запрос к серверу только один раз при загрузке компонента:

          <VsCode>{`useEffect(() => {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
}, []);`}</VsCode>
        </li>

        <li><b>Подписка и очистка </b>
          Например, подписка на событие прокрутки окна:

          <VsCode>{`useEffect(() => {
  function onScroll() {
    console.log('Прокрутка!');
  }

  window.addEventListener('scroll', onScroll);

  return () => {
    window.removeEventListener('scroll', onScroll);
  }
}, []);`}</VsCode>
        </li>

        <li><b>Обновление эффекта при изменении состояния</b>

          <VsCode>{`const [count, setCount] = useState(0);

useEffect(() => {
  console.log('count изменился:', count);
}, [count]);`}</VsCode>
        </li>
      </ul>

      <h3>Ошибки и подводные камни</h3>
      <ul>
        <li>
          Если не указать массив зависимостей, эффект запускается при каждом рендере, что может привести к снижению производительности и багам.
        </li>
        <li>
          Если не добавить в массив все необходимые зависимости, эффект может не сработать тогда, когда нужно.
        </li>
        <li>
          Обязательно возвращайте функцию очистки, если эффект создаёт подписки, таймеры или ресурсы, требующие очистки.
        </li>
      </ul>

      <h2>Массив зависимостей в useEffect: как и зачем</h2>

      <h3>Что такое массив зависимостей</h3>
      Второй аргумент хука useEffect — это массив значений (dependencies array), от которых зависит выполнение эффекта. React отслеживает эти значения, и если они изменяются, эффект перезапускается.

      Если вы не укажете этот массив, эффект будет запускаться **каждый раз при каждом обновлении компонента**.

      <h3>Разные варианты использования</h3>

      <ul>
        <li>
          <b>Без массива зависимостей</b> — эффект выполняется после каждого рендера (каждого обновления компонента). Например:

          <VsCode>{`useEffect(() => {
  console.log('Эффект вызывается после каждого рендера');
});`}</VsCode>
        </li>

        <li>
          <b>Пустой массив []</b> — эффект выполняется только один раз, когда компонент монтируется. Аналог componentDidMount в классах.

          <VsCode>{`useEffect(() => {
  console.log('Эффект вызывается только один раз при монтировании');
}, []);`}</VsCode>
        </li>

        <li>
          <b>Массив с зависимостями [dep1, dep2]</b> — эффект вызывается при первом рендере и при изменении любого из значений dep1 или dep2.

          <VsCode>{`const [count, setCount] = useState(0);

useEffect(() => {
  console.log('Эффект сработал, потому что count изменился:', count);
}, [count]);`}</VsCode>
        </li>
      </ul>

      <h3>Почему важно правильно указывать зависимости</h3>
      Если забыть указать зависимости, или указать не все, эффект может работать некорректно:

      - Может не обновляться при изменении важных переменных — баг.
      - Или наоборот, вызывать бесконечные циклы рендера, если эффекты постоянно запускаются.

      <h3>Чистка эффекта (функция очистки)</h3>
      Если эффект создаёт подписки, таймеры или что-то, что нужно отменить при обновлении или размонтировании, возвращайте из useEffect функцию очистки.

      Она вызывается:
      - перед следующим вызовом эффекта (если зависимости меняются)
      - при размонтировании компонента

      Пример с таймером:

      <VsCode>{`useEffect(() => {
  const id = setInterval(() => {
    console.log('Тик');
  }, 1000);

  return () => clearInterval(id); // очистка таймера
}, []); // запустится один раз`}</VsCode>

      <h3>Правила работы с зависимостями</h3>
      <ul>
        <li>
          В массив нужно включать все переменные и функции, которые используются внутри эффекта и могут изменяться.
        </li>
        <li>
          Если используете функции или объекты, которые создаются внутри компонента, лучше мемоизировать их (useCallback, useMemo), чтобы не вызывать эффект без нужды.
        </li>
        <li>
          Иногда можно намеренно исключать зависимости — для этого есть специальные комментарии, но делать это стоит осторожно.
        </li>
      </ul>

      <h2>Итого</h2>
      <ul>
        <li>useEffect позволяет выполнять побочные эффекты в функциональных компонентах.</li>
        <li>Используется для запросов, подписок, таймеров и других задач, не связанных с рендером.</li>
        <li>Принимает функцию эффекта и массив зависимостей.</li>
        <li>Массив зависимостей контролирует, когда эффект запускается.</li>
        <li>Функция очистки внутри эффекта помогает корректно освобождать ресурсы.</li>
        <li>Правильное указание зависимостей — залог стабильной работы эффекта и приложения.</li>
      </ul>
      <NavButtons prev={'/react/UseState'} next={'/react/UseRef'} />
    </section>
  )
}